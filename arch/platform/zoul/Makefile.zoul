### Zoul Makefile

ifndef CONTIKI
  $(error CONTIKI not defined! You must specify where CONTIKI resides!)
endif

### If no board is specified the default option is the RE-Mote revision B
BOARD ?= remote-revb
BOARDS = remote-reva remote-revb firefly-reva firefly orion

### As previously the RE-Mote revision A was plainly defined as remote, keep for
### backward compatibility
ifeq ($(BOARD), remote)
  override BOARD = remote-reva
endif

PYTHON = python
BSL_FLAGS += -e -w -v

BSL_SPEED ?= 460800

# Works in Linux and probably on OSX too (RTCC example)
CFLAGS += -DDATE="\"`date +"%02u %02d %02m %02y %02H %02M %02S"`\""

### Configure the build for the board and pull in board-specific sources
CONTIKI_TARGET_DIRS += . dev
CONTIKI_TARGET_DIRS += . $(BOARD)
PLATFORM_ROOT_DIR = $(CONTIKI)/arch/platform/$(TARGET)

### Include the board dir if one exists
-include $(PLATFORM_ROOT_DIR)/$(BOARD)/Makefile.$(BOARD)

### Include
CONTIKI_TARGET_SOURCEFILES += platform.c leds-arch.c
CONTIKI_TARGET_SOURCEFILES += leds.c cc1200-zoul-arch.c
CONTIKI_TARGET_SOURCEFILES += adc-zoul.c board-buttons.c zoul-sensors.c
CONTIKI_TARGET_SOURCEFILES += $(BOARD_SOURCEFILES)

CONTIKI_SOURCEFILES += $(CONTIKI_TARGET_SOURCEFILES)

### Define the CPU directory
CONTIKI_CPU=$(CONTIKI)/arch/cpu/cc2538
include $(CONTIKI_CPU)/Makefile.cc2538

MODULES += arch/dev/cc1200 arch/dev/rgb-led os/storage/cfs

BSL = $(CONTIKI)/tools/cc2538-bsl/cc2538-bsl.py

### Use the specific Zoul subplatform to query for connected devices
ifdef MOTELIST_ZOLERTIA
  MOTELIST_FLAGS += -b $(MOTELIST_ZOLERTIA)
endif

### Detect if a mote is connected over serial port
ifeq ($(HOST_OS),Darwin)
  USBDEVPREFIX=
  MOTELIST := $(CONTIKI)/tools/zolertia/motelist-zolertia-macos
  MOTES := $(shell $(MOTELIST) -c 2>&- | cut -f 2 -d ,)
else
### If we are not running under Mac, we assume Linux
  USBDEVPREFIX=
  MOTELIST := $(CONTIKI)/tools/zolertia/motelist-zolertia
  MOTES := $(shell $(MOTELIST) -b $(MOTELIST_ZOLERTIA) -c 2>&- | cut -f 2 -d , | \
            perl -ne 'print $$1 . " " if(m-(/dev/\w+)-);')
endif

### If PORT is defined, override to keep backward compatibility
ifdef PORT
  MOTES := $(PORT)
endif

### Check the BSL script exists
ifeq ($(wildcard $(BSL)), )
%.upload:
	@echo "ERROR: Could not find the cc2538-bsl script. Did you run 'git submodule update --init' ?"
else
### Upload to every MOTE
%.upload: $(foreach MOTE,$(MOTES),%.$(MOTE))
	@# Dummy recipe to prevent "No rule to make *.upload errors"
endif

### Variable that expands into a pattern rule to upload to a given MOTE.
### Requires $(MOTE) to be defined
### $$$$ Double escapes $s that need to be passed to the shell - once for when make parses UPLOAD_RULE, and once for when the expanded rule is parsed by make.
define UPLOAD_RULE
%.$(MOTE): %.bin %.elf
	@echo "Flashing $(MOTE)"
	@BSL_ADDRESS=`$(OBJDUMP) -h $$*.elf | grep -B1 LOAD | \
	             grep -Ev 'LOAD|\-\-' | awk '{print "0x" $$$$5}' | \
	             sort -g | head -1`; \
	$(PYTHON) $(BSL) $(BSL_FLAGS) -b $(BSL_SPEED) -a $$$${BSL_ADDRESS} -p $(MOTE) $$<
endef

### Create an upload rule for every MOTE connected
$(foreach MOTE,$(MOTES),$(eval $(UPLOAD_RULE)))

motelist:
	$(MOTELIST)
zoul-motelist:
	$(MOTELIST) $(MOTELIST_FLAGS)
zoul-motes:
	@echo $(MOTES)

### For the login etc targets
BAUDRATE = 115200
PORT = $(USBDEVPREFIX)$(firstword $(MOTES))
